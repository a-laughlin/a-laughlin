import './lodash-es/_listCacheClear.js-e2c31d6d.js';
import './lodash-es/eq.js-3067b71d.js';
import './lodash-es/_assocIndexOf.js-9d262dc0.js';
import './lodash-es/_listCacheDelete.js-73448065.js';
import './lodash-es/_listCacheGet.js-ab0a3256.js';
import './lodash-es/_listCacheHas.js-3166b85c.js';
import './lodash-es/_listCacheSet.js-de9e7743.js';
import './lodash-es/_ListCache.js-31797373.js';
import './lodash-es/_stackClear.js-583ff074.js';
import './lodash-es/_stackDelete.js-51c69537.js';
import './lodash-es/_stackGet.js-4846d0cd.js';
import './lodash-es/_stackHas.js-65485a5c.js';
import './lodash-es/_freeGlobal.js-ac63e052.js';
import './lodash-es/_root.js-82806f10.js';
import './lodash-es/_Symbol.js-09c49294.js';
import './lodash-es/_getRawTag.js-f59ed6e5.js';
import './lodash-es/_objectToString.js-57a29940.js';
import './lodash-es/_baseGetTag.js-f3ef6f41.js';
import './lodash-es/isObject.js-52553cde.js';
import './lodash-es/isFunction.js-e7b830c1.js';
import './lodash-es/_coreJsData.js-d0cf551e.js';
import './lodash-es/_isMasked.js-67721d8e.js';
import './lodash-es/_toSource.js-b768b872.js';
import './lodash-es/_baseIsNative.js-c2ce2406.js';
import './lodash-es/_getValue.js-18c9d5bc.js';
import './lodash-es/_getNative.js-6ce67c8b.js';
import './lodash-es/_Map.js-26262f48.js';
import './lodash-es/_nativeCreate.js-478e8045.js';
import './lodash-es/_hashClear.js-6690e721.js';
import './lodash-es/_hashDelete.js-5fa65fee.js';
import './lodash-es/_hashGet.js-73445d8e.js';
import './lodash-es/_hashHas.js-896bca19.js';
import './lodash-es/_hashSet.js-7b0463bb.js';
import './lodash-es/_Hash.js-f6717b1a.js';
import './lodash-es/_mapCacheClear.js-10156fde.js';
import './lodash-es/_isKeyable.js-a6bd7f34.js';
import './lodash-es/_getMapData.js-6312c74c.js';
import './lodash-es/_mapCacheDelete.js-01a46502.js';
import './lodash-es/_mapCacheGet.js-42005c75.js';
import './lodash-es/_mapCacheHas.js-0989f7fc.js';
import './lodash-es/_mapCacheSet.js-15b69a11.js';
import './lodash-es/_MapCache.js-0e911fa6.js';
import './lodash-es/_stackSet.js-565499c9.js';
import './lodash-es/_Stack.js-283d3e23.js';
import './lodash-es/_defineProperty.js-3ce473e1.js';
import './lodash-es/_baseAssignValue.js-e6945a61.js';
import './lodash-es/_assignMergeValue.js-4893b41f.js';
import './lodash-es/_createBaseFor.js-41ed5751.js';
import './lodash-es/_baseFor.js-abbb37ca.js';
import './lodash-es/_cloneBuffer.js-fda27ee5.js';
import './lodash-es/_Uint8Array.js-8616f24c.js';
import './lodash-es/_cloneArrayBuffer.js-5068fcff.js';
import './lodash-es/_cloneTypedArray.js-cdcdcc65.js';
import './lodash-es/_copyArray.js-60683993.js';
import './lodash-es/_baseCreate.js-1fe7d114.js';
import './lodash-es/_overArg.js-a472e8ea.js';
import './lodash-es/_getPrototype.js-30d5af28.js';
import './lodash-es/_isPrototype.js-28e760ef.js';
import './lodash-es/_initCloneObject.js-451623ee.js';
import './lodash-es/isObjectLike.js-bf43cd33.js';
import './lodash-es/_baseIsArguments.js-ea906a63.js';
import './lodash-es/isArguments.js-49778255.js';
import './lodash-es/isArray.js-348c388d.js';
import './lodash-es/isLength.js-0b7b9fd1.js';
import './lodash-es/isArrayLike.js-a791d85f.js';
import './lodash-es/isArrayLikeObject.js-9ec94c2e.js';
import './lodash-es/stubFalse.js-2cdba8d4.js';
import './lodash-es/isBuffer.js-b51562a3.js';
import { i as isPlainObject } from './lodash-es/isPlainObject.js-f82871af.js';
import './lodash-es/_baseIsTypedArray.js-94c2af13.js';
import './lodash-es/_baseUnary.js-6df1a89e.js';
import './lodash-es/_nodeUtil.js-62848496.js';
import './lodash-es/isTypedArray.js-5ad2fd2e.js';
import './lodash-es/_safeGet.js-477e482b.js';
import './lodash-es/_assignValue.js-85b1adb0.js';
import './lodash-es/_copyObject.js-85710492.js';
import './lodash-es/_baseTimes.js-7e32212b.js';
import './lodash-es/_isIndex.js-75de89e7.js';
import './lodash-es/_arrayLikeKeys.js-9d4926bb.js';
import './lodash-es/_nativeKeysIn.js-11dd4ac3.js';
import './lodash-es/_baseKeysIn.js-94b39114.js';
import './lodash-es/keysIn.js-a456e211.js';
import './lodash-es/toPlainObject.js-abc6a198.js';
import './lodash-es/_baseMergeDeep.js-9ff81186.js';
import './lodash-es/_baseMerge.js-94b3d7a7.js';
import './lodash-es/identity.js-ddb76187.js';
import './lodash-es/_apply.js-367f18b6.js';
import './lodash-es/_overRest.js-96a11039.js';
import './lodash-es/constant.js-f1c147da.js';
import './lodash-es/_baseSetToString.js-0f32ff52.js';
import './lodash-es/_shortOut.js-db5b33fd.js';
import './lodash-es/_setToString.js-b1e00eb2.js';
import './lodash-es/_baseRest.js-7e6e80dd.js';
import './lodash-es/_isIterateeCall.js-2264efb2.js';
import './lodash-es/_createAssigner.js-9c754eed.js';
import { m as merge } from './lodash-es/merge.js-442025fa.js';
import './lodash-es/isSymbol.js-2b98fa01.js';
import './lodash-es/_isKey.js-20c1b706.js';
import './lodash-es/memoize.js-169583e3.js';
import './lodash-es/_memoizeCapped.js-497b94a3.js';
import './lodash-es/_stringToPath.js-14426231.js';
import './lodash-es/_arrayMap.js-efbe07df.js';
import './lodash-es/_baseToString.js-2c117502.js';
import './lodash-es/toString.js-054ab19d.js';
import './lodash-es/_castPath.js-23467a97.js';
import './lodash-es/_toKey.js-00bd10e9.js';
import './lodash-es/_baseSet.js-1e97817a.js';
import './lodash-es/_arrayEvery.js-93f9a99b.js';
import './lodash-es/_setCacheAdd.js-6cf11f54.js';
import './lodash-es/_setCacheHas.js-077b149c.js';
import './lodash-es/_SetCache.js-92df99dc.js';
import './lodash-es/_arraySome.js-648bb11f.js';
import './lodash-es/_cacheHas.js-aa223a23.js';
import './lodash-es/_equalArrays.js-15326ddd.js';
import './lodash-es/_mapToArray.js-1b7d050b.js';
import './lodash-es/_setToArray.js-daaaf907.js';
import './lodash-es/_equalByTag.js-5ebaad3d.js';
import './lodash-es/_arrayPush.js-6ac3b0b0.js';
import './lodash-es/_baseGetAllKeys.js-d353ff0c.js';
import './lodash-es/_arrayFilter.js-6c6cb9e4.js';
import './lodash-es/stubArray.js-a0b52c3f.js';
import './lodash-es/_getSymbols.js-aee7efbf.js';
import './lodash-es/_nativeKeys.js-3a24687a.js';
import './lodash-es/_baseKeys.js-a855521c.js';
import './lodash-es/keys.js-f4a95bd3.js';
import './lodash-es/_getAllKeys.js-0b0492cc.js';
import './lodash-es/_equalObjects.js-37b603d0.js';
import './lodash-es/_DataView.js-25495e22.js';
import './lodash-es/_Promise.js-222457f4.js';
import './lodash-es/_Set.js-0d56afa2.js';
import './lodash-es/_WeakMap.js-ad7381a2.js';
import './lodash-es/_getTag.js-9cc934cc.js';
import './lodash-es/_baseIsEqualDeep.js-05ed3446.js';
import './lodash-es/_baseIsEqual.js-2081c9b2.js';
import './lodash-es/_baseIsMatch.js-fe8d464f.js';
import './lodash-es/_isStrictComparable.js-a9828370.js';
import './lodash-es/_getMatchData.js-8a722ba0.js';
import './lodash-es/_matchesStrictComparable.js-d19af892.js';
import './lodash-es/_baseMatches.js-39913338.js';
import './lodash-es/_baseGet.js-a279f2a7.js';
import './lodash-es/get.js-addb1d30.js';
import './lodash-es/_baseHasIn.js-5eb272a4.js';
import './lodash-es/_hasPath.js-cb394a0c.js';
import './lodash-es/hasIn.js-2f0ad596.js';
import './lodash-es/_baseMatchesProperty.js-5334e4c8.js';
import './lodash-es/_baseProperty.js-00c82e77.js';
import './lodash-es/_basePropertyDeep.js-e8318885.js';
import './lodash-es/property.js-ddd8f638.js';
import './lodash-es/_baseIteratee.js-718e1a1e.js';
import './lodash-es/_isFlattenable.js-8ef4abd2.js';
import './lodash-es/_baseFlatten.js-8b85ebbc.js';
import './lodash-es/flatten.js-06038df6.js';
import './lodash-es/_flatRest.js-d229910c.js';
import './lodash-es/_createOver.js-5e666ff5.js';
import { o as overEvery } from './lodash-es/overEvery.js-85c2260f.js';
import { o as overSome } from './lodash-es/overSome.js-2ada7e25.js';
import './lodash-es/_baseForOwn.js-f2105544.js';
import './lodash-es/_createBaseEach.js-2bcc6476.js';
import './lodash-es/_baseEach.js-f31c688f.js';
import './lodash-es/_baseMap.js-781eedcf.js';
import './lodash-es/_baseSortBy.js-2eea9fb7.js';
import './lodash-es/_compareAscending.js-b327f9ec.js';
import './lodash-es/_compareMultiple.js-4ef115e3.js';
import './lodash-es/_baseOrderBy.js-1c53f017.js';
import { s as sortBy } from './lodash-es/sortBy.js-cfaf310e.js';
import { i as isString } from './lodash-es/isString.js-650ac401.js';
import './lodash-es/_basePickBy.js-9e8e587d.js';
import './lodash-es/_basePick.js-4883a589.js';
import { p as pick } from './lodash-es/pick.js-88ae7d68.js';
export { u as uniqueId } from './lodash-es/uniqueId.js-cdc34c97.js';

// curry/compose/pipe, for later fns
let curry,compose,pipe;
const identity=x=>x;
if (process.env.NODE_ENV !== 'production') {
  // debugging versions
  const fToString = fn => fn.name ? fn.name : fn.toString();
  curry =(fn) => {
    const f1 = (...args) => {
      if (args.length >= fn.length) { return fn(...args) }      const f2 = (...more) => f1(...args, ...more);
      f2.toString = () => `${fToString(fn)}(${args.join(', ')})`;
      return Object.defineProperty(f2, `name`, { value: `${fToString(fn)}(${args.join(', ')})` });
    };
    f1.toString = () => fToString(fn);
    return Object.defineProperty(f1, `name`, { value: fToString(fn) });
  };

  // based on https://dev.to/ascorbic/creating-a-typed-compose-function-in-typescript-3-351i

  compose = (fn=identity,...fns) => {
    const composed = (...args) => fns.reduceRight((acc, f) => f(acc), fn(...args));
    composed.toString = () => `compose(${fns.map(fToString).join(', ')})`;
    return composed;
  };
  pipe = (fn=identity,...fns) => {
    const piped = (...args) => fns.reduce((acc, f) => f(acc), fn(...args));
    piped.toString = () => `pipe(${fns.reverse().map(fToString).join(', ')})`;
    return piped;
  };
} else {
  // eslint-disable-next-line
  curry = fn => (...args) => args.length >= fn.length ? fn(...args) : curry(fn.bind(null, ...args));
  // eslint-disable-next-line
  compose = (fn=identity,...fns) => (...args) => fns.reduceRight((acc, f) => f(acc), fn(...args));
  // eslint-disable-next-line
  pipe = (fn=identity,...fns) => (...args) => fns.reduce((acc, f) => f(acc), fn(...args));
}


// stubs

const stubNull = ()=>null;
const stubArray = ()=>[];
const stubObject = ()=>({});
const stubString = ()=>'';
const stubTrue = ()=>true;
const stubFalse = ()=>false;
const noop = ()=>{};

// const stubs
const frozenEmptyArray = Object.freeze([]);
const frozenEmptyObject = Object.freeze(Object.create(null));


// predicates
// export {isError,isInteger,isNumber,isObjectLike,hasIn,has,isWeakMap,isWeakSet,isMap,
//   isSet,isEmpty,isString,isPlainObject,isFunction,isNull,isUndefined,every,conforms} from 'lodash-es';
const isArray = Array.isArray.bind(Array);
const isFalsy = arg=>!arg;
const isTruthy = arg=>!!arg;
const is = val1=>val2=>val1===val2;
const isUndefOrNull = val => val == undefined; // eslint-disable-line
const len = num=>({length})=>length===num;
const len0 = len(0);
const len1 = len(1);
const isProductionEnv = ()=>process.env.NODE_ENV === 'production';
const matches = arg=>matchesFP(arg);
const isDeepEqual=(a,b)=>{ // decently fast check on objects and arrays
  if (a===b)return true;
  if (typeof a !== 'object')return a===b;
  if (Array.isArray(a)){
    if (Array.isArray(b)===false||a.length!==b.length)return false;
    let key=-1,L=toCheck.length;
    while (++key<L) if (isCached(a[key],b[key])===false) return false;
    return true;
  }
  let key;
  for (key in toCheck) if (isCached(a[key],b[key])===false) return false;
  return true;
};

// debugging
const plog = (msg='')=>pipeVal=>console.log(msg,pipeVal) || pipeVal;

// flow
const dpipe = (data,...args)=>pipe(...args)(data);

// functions
const acceptArrayOrArgs = fn=>(...args)=>args.length>1 ? fn(args) : fn(...args);
const invokeArgsOnObj = (...args) => mapValues(fn=>fn(...args));
const invokeObjectWithArgs = (obj)=>(...args) => mapValues(fn=>isFunction(fn) ? fn(...args) : fn)(obj);
const mergeToBlank = acceptArrayOrArgs(vals => merge({},...vals));

const overObj = obj=>(...args)=>mo(f=>f(...args))(obj);
const converge = (arg)=>(isArray(arg)?over:overObj)(arg);

// casting
const constant = x=>_=>x;
const ensureArray = (val=[])=>isArray(val) ? val : [val];
const ensureString = (val)=>isString(val) ? val : `${val}`;
const ensureFunction = (arg)=>typeof arg==='function'?arg:constant(arg);
const ensureProp = (obj,key,val)=>{obj.hasOwnProperty(key) ? obj[key] : (obj[key]=val);return obj;};
const ensurePropWith = fn=>(obj,key,val)=>ensureProp(obj,key,fn(obj,key,val));
const ensurePropIsArray = ensurePropWith(stubArray);
const ensurePropIsObject = ensurePropWith(stubObject);

// logic
const not = fn=>arg=>!fn(arg);
const ifElseUnary = (pred,T,F=identity)=>arg=>pred(arg)?T(arg):F(arg);
const ifElse = (pred,T,F=identity)=>(...args)=>(pred(...args) ? T : F)(...args);
const and = (...args)=>overEvery(args);
const or = (...args)=>overSome(...args);
const none = not(or);
const xor = fn=>pipe(filter(fn),len1);
const condNoExec = acceptArrayOrArgs(arrs=>(...x)=>{for (let [pred,val] of arrs){if(pred(...x)){return val;}}});
const cond = acceptArrayOrArgs(arrs=>(...args)=>ensureFunction(condNoExec(...arrs)(...args))(...args));



// Array methods
const slice = (...sliceArgs)=>arr=>arr.slice(...sliceArgs);
const reverse = arr=>arr.slice(0).reverse(); // immutable array reverse
const sort = coll=>sortBy(coll,null);




// collections
const makeCollectionFn=(arrayFn,objFn)=>fn=>{
  const aFn=arrayFn(fn);
  const oFn=objFn(fn);
  return coll=>isArray(coll)?aFn(coll):oFn(coll);
};
const transArrayToObject = fn => (coll=[]) => {
  const l = coll.length, acc = Object.create(null);
  let k = -1;
  while (++k < l) fn(acc, coll[k], k, coll);
  return acc;
};
const transArrayToArray = fn => (coll=[]) => {
  const l = coll.length, acc = [];
  let k = -1;
  while (++k < l) fn(acc, coll[k], k, coll);
  return acc;
};
const transObjectToObject = fn => (coll={}) => {
  let k, acc = Object.create(null);
  for (k in coll) fn(acc, coll[k], k, coll);
  return acc;
};
const transObjectToArray = fn => (coll={}) => {
  let k, acc = [];
  for (k in coll) fn(acc, coll[k], k, coll);
  return acc;
};
const immutableTransObjectToObject = fn => (coll={}) => {
  let k, acc = {},changed=false;
  for (k in coll) {
    fn(acc, coll[k], k, coll);
    if (acc[k]!==coll[k]) changed=true;
  }
  return changed===false?coll:acc;
};
const immutableFilterObjectToObject = (pred=(v,k,c)=>true) => (coll={}) => {
  let k, acc = {},changed=false;
  for (k in coll)
    pred(coll[k], k, coll)
      ? (acc[k]=coll[k])
      : (changed=true);
  return changed===true?acc:coll;
};
const transX = makeCollectionFn(transArrayToArray,transObjectToObject);
const transToObject = makeCollectionFn(transArrayToObject,transObjectToObject);
const transToArray = makeCollectionFn(transArrayToArray,transObjectToArray);
// utility functions that return the same type. For performance, user fn is only call in loop.
// equivalent to lodash reduce(coll,isArray(coll)[]?{},fn)
const reduce = fn => (coll,acc) => {
  let k = -1;
  if (isArray(coll)) {
    const l = coll.length;
    while (++k < l) (acc = fn(acc, coll[k], k, coll));
  } else for (k in coll) (acc = fn(acc, coll[k], k, coll));
  return acc;
};

// backwards compat
// shortcuts for the most common collection operations
// prefixes = r,m,f,o,fm = reduce,map,filter,omit,filter+map
// suffixes = o,a,x = toObject,toArray,toX (where X is the same type as input)
const ro=transToObject; 
const ra=transToArray; // backwards compat
const ma=fn=>transToArray((a,v,k)=>a[a.length]=fn(v,k)); // _ equiv map
const mo=fn=>transToObject((a,v,k)=>a[k]=fn(v,k)); // _ equiv mapValues
const fa=pred=>transToArray((a,v,k)=>pred(v,k)&&(a[a.length]=v)); // _ equiv filter
const fo=pred=>transToObject((a,v,k)=>pred(v,k)&&(a[k]=v)); // _ equiv pickBy
const oa=pred=>transToArray((a,v,k)=>!pred(v,k)&&(a[a.length]=v)); // _ equiv withoutBy
const oo=pred=>transToObject((a,v,k)=>!pred(v,k)&&(a[k]=v)); // _ equiv pickBy

// partionObject((v,k)=>k=='a',(v,k)=>k!='a')({a:1,b:2,c:3}) =>[{a:1},{b:1,c:2}]
// partionObject((v,k)=>v==1,(v,k)=>v!=1)({a:1,b:2,c:3}) =>[{a:1,b:1},{c:2}]
// partionObject((v,k)=>v==1)({a:1,b:2,c:3}) =>[{a:1,b:1},{c:2}]
const partitionObject = (...preds)=>over([...(preds.map(fo)),fo(none(preds))]);
const partitionArray = (...preds)=>over([...(preds.map(fa)),fa(none(preds))]);
const partition = makeCollectionFn(partitionArray,partitionObject);




// indexers
const keyBy = ifElseUnary(isString,
  (id='id')=>transToObject((o,v,k)=>{o[v[id]]=v;}),
  (fn=x=>x.id)=>transToObject((o,v,k)=>{o[fn(v,k)]=v;})
);
const pushToArray=(a=[],v)=>{a[a.length]=v;return a;};
const pushToArrayProp=(acc={},v,k)=>{acc[k]=pushToArray(acc[k],v);return acc;};
const groupBy = fn=>transToObject((o,v,k,c)=>pushToArrayProp(o,v,fn(v,k)));
const groupByKeys = transToObject((o,v,k)=>{for (k in v)pushToArrayProp(o,v,k);});
const groupByValues = transToObject((o,v)=>{
  let k,vv;
  for (k in v)
    for (vv of ensureArray(v[k]))
      pushToArrayProp(o,v,ensureString(vv));
});


// getters
const pget = cond(
  [isString,str=>{
    str=str.split('.');
    return targ=>str.reduce((t,s)=>isArray(t) && !isInteger(+s) ? t.map(o=>o[s]) : t[s], targ)
  }],
  [isArray,keys=>obj=>pick(obj,keys)],
  [isPlainObject, obj=>target=>mo(f=>pget(f)(target))(obj)],
  [stubTrue,identity], // handles the function case
);
const first = c=>{
  if (isArray(c)) return c[i];
  for (const k in c)return c[k];
};
const last = c =>{
  c=isArray(c)?c:Object.values(c);
  return c[c.length-1];
};



// Objects

const renameProps = obj=>target=>{
  let newKey,oldKey,targetCopy = {...target};
  for (newKey in obj){
    oldKey=obj[newKey];
    targetCopy[newKey]=target[oldKey];
    delete targetCopy[oldKey];
  }
  return targetCopy;
};
const objStringifierFactory = ({
  getPrefix=()=>'',
  getSuffix=()=>'',
  mapPairs=x=>x,
  keySplit = '=',
  pairSplit = '&'
} = {})=>(input={})=>{
  const output = Object.keys(input)
  .map(k=>([k, input[k]].map(mapPairs).join(keySplit)))
  .join(pairSplit);
  return getPrefix(input,output) + output + getSuffix(input, output);
};
const objToUrlParams = objStringifierFactory({
  getPrefix:(input,output)=>output ? '?' : '',
  mapPairs:encodeURIComponent,
});





const isPromise = x=>typeof x==='object'&&x!==null&&typeof x.then==='function';
const transduce = (acc, combiner , transducer, collection) =>{
  let k,l;
  const reducer = transducer(combiner);
  if (Array.isArray(collection))
    for (k=-1, l = collection.length;++k < l;)
      (acc=isPromise(acc)
        ? acc.then(a=>reducer(a, collection[k], k, collection))
        : reducer(acc, collection[k], k, collection));
  else if (typeof collection === 'object')
    for (k in collection)
      (acc=isPromise(acc)
        ? acc.then(a=>reducer(a, collection[k], k, collection))
        : reducer(acc, collection[k], k, collection));
  return acc;
};

const appendArrayReducer = (acc,v)=>{acc[acc.length]=v;return acc;};
const appendObjectReducer = (acc,v,k)=>{acc[k]=v;return acc;};
const tdToArray = transducer=>collection=>transduce([], appendArrayReducer, transducer, collection);
const tdToObject = transducer=>collection=>transduce(({}), appendObjectReducer, transducer, collection);
const tdToSame = transducer=>collection=>(Array.isArray(collection)?tdToArray:tdToObject)(transducer)(collection);
const tdToInitial = transducer=>initial=>transduce(initial, identity, transducer, [initial]);

const tdMap = (mapper) => (nextReducer) => (a,v,k,c) => nextReducer(a,mapper(v,k,c),k,c);
const tdFilter = (pred) => (nextReducer) => (a,v,k,c) => pred(v,k,c) ? nextReducer(a,v,k,c) : a;
const tdOmit = (pred) => (nextReducer) => (a,v,k,c) => pred(v,k,c) ? a: nextReducer(a,v,k,c);
const tdReduce = (reducer) => (nextReducer) => (a,v,k,c) =>nextReducer(reducer(a,v,k,c),v,k,c);
const tdTrans = (reducer) => (nextReducer) => (a,v,k,c)=>{
  reducer(a,v,k,c);
  nextReducer(a,v,k,c);
  return a;
};
const tdOver = (...reducers) => (nextReducer) => (a,v,k,c) => {
  return nextReducer(reducers.reduce((aa,r,i)=>aa[aa.length]=r(aa,v,i,c),k,c,[]),v,k,c);
};
const tdFlat = tdReduce((a) => {
  return a.reduce((acc,subArr)=>{for (let s of subArr)acc[acc.length]=s;return acc;},[]);
});

const transduceRecursive = transducer=>{
  const walkReducer = tdToSame(compose(
    transducer,
    tdMap(v=>typeof v==='object'?walkReducer(v):v)
  ));
  return walkReducer;
};
// lodash equivalents
const memoize = (fn, by = identity) => {
  const mFn = (...x) => { const k = by(...x); return fn(...(mFn.cache.has(k) ? mFn.cache.get(k) : (mFn.cache.set(k, x) && x))) };
  mFn.cache = new WeakMap(); // eslint-disable-line
  return mFn;
};
const tdKeyBy = (by = x => x.id) => next=>(o,v,k,c)=>next(o,v,by(v,k,c),c);

const diffObjs = (a={},b={}) => {
  // returns subsets and changed values for object properties
  // a !in b, b !in a, a union b, a intersection b (a[x] and b[x] exist), and changed intersections (i.e. a[x]!==b[x])
  // works with objects, and object-based collections already keyed by their ids
  const anb = {}, bna = {}, aib = {}, aub = {}, changed = {};
  let k, anbc = 0, bnac = 0, aibc = 0, changedc = 0;
  for (k in a) k in b ?
    (aibc += aub[k] = aib[k] = (a[k] === b[k] ? 1 : (changedc += changed[k] = 1)))
    : (anbc += aub[k] = anb[k] = 1);
  for (k in b) k in a
    ? ((k in aib)
      ? (aub[k] = aib[k] = 1)
      : (aibc += aub[k] = aib[k] = (a[k] === b[k] ? 1 : (changedc += changed[k] = 1))))
    : (bnac += aub[k] = bna[k] = 1);
  return { anb, anbc, bna, bnac, aib, aibc, aub, aubc: anbc + bnac + aibc, changed, changedc, a, b };
};

// TODO decide behavior when collections are arrays and no "by" key to diff them by
const diffBy = (by=x=>x.id, args = []) => by ? diffObjs(...args.map(keyBy(by))) : diffObjs(args);

export { acceptArrayOrArgs, and, appendArrayReducer, appendObjectReducer, compose, cond, condNoExec, constant, converge, curry, diffBy, diffObjs, dpipe, ensureArray, ensureFunction, ensureProp, ensurePropIsArray, ensurePropIsObject, ensurePropWith, ensureString, fa, first, fo, frozenEmptyArray, frozenEmptyObject, groupBy, groupByKeys, groupByValues, identity, ifElse, ifElseUnary, immutableFilterObjectToObject, immutableTransObjectToObject, invokeArgsOnObj, invokeObjectWithArgs, is, isArray, isDeepEqual, isFalsy, isProductionEnv, isPromise, isTruthy, isUndefOrNull, keyBy, last, len, len0, len1, ma, matches, memoize, mergeToBlank, mo, none, noop, not, oa, objStringifierFactory, objToUrlParams, oo, or, overObj, partition, pget, pipe, plog, ra, reduce, renameProps, reverse, ro, slice, sort, stubArray, stubFalse, stubNull, stubObject, stubString, stubTrue, tdFilter, tdFlat, tdKeyBy, tdMap, tdOmit, tdOver, tdReduce, tdToArray, tdToInitial, tdToObject, tdToSame, tdTrans, transToArray, transToObject, transX, transduce, transduceRecursive, xor };
