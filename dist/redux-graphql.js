import './lodash-es/_listCacheClear.js-e2c31d6d.js';
import './lodash-es/eq.js-3067b71d.js';
import './lodash-es/_assocIndexOf.js-9d262dc0.js';
import './lodash-es/_listCacheDelete.js-73448065.js';
import './lodash-es/_listCacheGet.js-ab0a3256.js';
import './lodash-es/_listCacheHas.js-3166b85c.js';
import './lodash-es/_listCacheSet.js-de9e7743.js';
import './lodash-es/_ListCache.js-31797373.js';
import './lodash-es/_stackClear.js-583ff074.js';
import './lodash-es/_stackDelete.js-51c69537.js';
import './lodash-es/_stackGet.js-4846d0cd.js';
import './lodash-es/_stackHas.js-65485a5c.js';
import './lodash-es/_freeGlobal.js-ac63e052.js';
import './lodash-es/_root.js-82806f10.js';
import './lodash-es/_Symbol.js-09c49294.js';
import './lodash-es/_getRawTag.js-f59ed6e5.js';
import './lodash-es/_objectToString.js-57a29940.js';
import './lodash-es/_baseGetTag.js-f3ef6f41.js';
import './lodash-es/isObject.js-52553cde.js';
import './lodash-es/isFunction.js-e7b830c1.js';
import './lodash-es/_coreJsData.js-d0cf551e.js';
import './lodash-es/_isMasked.js-67721d8e.js';
import './lodash-es/_toSource.js-b768b872.js';
import './lodash-es/_baseIsNative.js-c2ce2406.js';
import './lodash-es/_getValue.js-18c9d5bc.js';
import './lodash-es/_getNative.js-6ce67c8b.js';
import './lodash-es/_Map.js-26262f48.js';
import './lodash-es/_nativeCreate.js-478e8045.js';
import './lodash-es/_hashClear.js-6690e721.js';
import './lodash-es/_hashDelete.js-5fa65fee.js';
import './lodash-es/_hashGet.js-73445d8e.js';
import './lodash-es/_hashHas.js-896bca19.js';
import './lodash-es/_hashSet.js-7b0463bb.js';
import './lodash-es/_Hash.js-f6717b1a.js';
import './lodash-es/_mapCacheClear.js-10156fde.js';
import './lodash-es/_isKeyable.js-a6bd7f34.js';
import './lodash-es/_getMapData.js-6312c74c.js';
import './lodash-es/_mapCacheDelete.js-01a46502.js';
import './lodash-es/_mapCacheGet.js-42005c75.js';
import './lodash-es/_mapCacheHas.js-0989f7fc.js';
import './lodash-es/_mapCacheSet.js-15b69a11.js';
import './lodash-es/_MapCache.js-0e911fa6.js';
import './lodash-es/_stackSet.js-565499c9.js';
import './lodash-es/_Stack.js-283d3e23.js';
import './lodash-es/_defineProperty.js-3ce473e1.js';
import './lodash-es/_baseAssignValue.js-e6945a61.js';
import './lodash-es/_assignMergeValue.js-4893b41f.js';
import './lodash-es/_createBaseFor.js-41ed5751.js';
import './lodash-es/_baseFor.js-abbb37ca.js';
import './lodash-es/_cloneBuffer.js-fda27ee5.js';
import './lodash-es/_Uint8Array.js-8616f24c.js';
import './lodash-es/_cloneArrayBuffer.js-5068fcff.js';
import './lodash-es/_cloneTypedArray.js-cdcdcc65.js';
import './lodash-es/_copyArray.js-60683993.js';
import './lodash-es/_baseCreate.js-1fe7d114.js';
import './lodash-es/_overArg.js-a472e8ea.js';
import './lodash-es/_getPrototype.js-30d5af28.js';
import './lodash-es/_isPrototype.js-28e760ef.js';
import './lodash-es/_initCloneObject.js-451623ee.js';
import './lodash-es/isObjectLike.js-bf43cd33.js';
import './lodash-es/_baseIsArguments.js-ea906a63.js';
import './lodash-es/isArguments.js-49778255.js';
import './lodash-es/isArray.js-348c388d.js';
import './lodash-es/isLength.js-0b7b9fd1.js';
import './lodash-es/isArrayLike.js-a791d85f.js';
import './lodash-es/isArrayLikeObject.js-9ec94c2e.js';
import './lodash-es/stubFalse.js-2cdba8d4.js';
import './lodash-es/isBuffer.js-b51562a3.js';
import './lodash-es/isPlainObject.js-f82871af.js';
import './lodash-es/_baseIsTypedArray.js-94c2af13.js';
import './lodash-es/_baseUnary.js-6df1a89e.js';
import './lodash-es/_nodeUtil.js-62848496.js';
import './lodash-es/isTypedArray.js-5ad2fd2e.js';
import './lodash-es/_safeGet.js-477e482b.js';
import './lodash-es/_assignValue.js-85b1adb0.js';
import './lodash-es/_copyObject.js-85710492.js';
import './lodash-es/_baseTimes.js-7e32212b.js';
import './lodash-es/_isIndex.js-75de89e7.js';
import './lodash-es/_arrayLikeKeys.js-9d4926bb.js';
import './lodash-es/_nativeKeysIn.js-11dd4ac3.js';
import './lodash-es/_baseKeysIn.js-94b39114.js';
import './lodash-es/keysIn.js-a456e211.js';
import './lodash-es/toPlainObject.js-abc6a198.js';
import './lodash-es/_baseMergeDeep.js-9ff81186.js';
import './lodash-es/_baseMerge.js-94b3d7a7.js';
import './lodash-es/identity.js-ddb76187.js';
import './lodash-es/_apply.js-367f18b6.js';
import './lodash-es/_overRest.js-96a11039.js';
import './lodash-es/constant.js-f1c147da.js';
import './lodash-es/_baseSetToString.js-0f32ff52.js';
import './lodash-es/_shortOut.js-db5b33fd.js';
import './lodash-es/_setToString.js-b1e00eb2.js';
import './lodash-es/_baseRest.js-7e6e80dd.js';
import './lodash-es/_isIterateeCall.js-2264efb2.js';
import './lodash-es/_createAssigner.js-9c754eed.js';
import './lodash-es/merge.js-442025fa.js';
import './lodash-es/isSymbol.js-2b98fa01.js';
import './lodash-es/_isKey.js-20c1b706.js';
import './lodash-es/memoize.js-169583e3.js';
import './lodash-es/_memoizeCapped.js-497b94a3.js';
import './lodash-es/_stringToPath.js-14426231.js';
import './lodash-es/_arrayMap.js-efbe07df.js';
import './lodash-es/_baseToString.js-2c117502.js';
import './lodash-es/toString.js-054ab19d.js';
import './lodash-es/_castPath.js-23467a97.js';
import './lodash-es/_toKey.js-00bd10e9.js';
import './lodash-es/_baseSet.js-1e97817a.js';
import './lodash-es/_arrayEvery.js-93f9a99b.js';
import './lodash-es/_setCacheAdd.js-6cf11f54.js';
import './lodash-es/_setCacheHas.js-077b149c.js';
import './lodash-es/_SetCache.js-92df99dc.js';
import './lodash-es/_arraySome.js-648bb11f.js';
import './lodash-es/_cacheHas.js-aa223a23.js';
import './lodash-es/_equalArrays.js-15326ddd.js';
import './lodash-es/_mapToArray.js-1b7d050b.js';
import './lodash-es/_setToArray.js-daaaf907.js';
import './lodash-es/_equalByTag.js-5ebaad3d.js';
import './lodash-es/_arrayPush.js-6ac3b0b0.js';
import './lodash-es/_baseGetAllKeys.js-d353ff0c.js';
import './lodash-es/_arrayFilter.js-6c6cb9e4.js';
import './lodash-es/stubArray.js-a0b52c3f.js';
import './lodash-es/_getSymbols.js-aee7efbf.js';
import './lodash-es/_nativeKeys.js-3a24687a.js';
import './lodash-es/_baseKeys.js-a855521c.js';
import './lodash-es/keys.js-f4a95bd3.js';
import './lodash-es/_getAllKeys.js-0b0492cc.js';
import './lodash-es/_equalObjects.js-37b603d0.js';
import './lodash-es/_DataView.js-25495e22.js';
import './lodash-es/_Promise.js-222457f4.js';
import './lodash-es/_Set.js-0d56afa2.js';
import './lodash-es/_WeakMap.js-ad7381a2.js';
import './lodash-es/_getTag.js-9cc934cc.js';
import './lodash-es/_baseIsEqualDeep.js-05ed3446.js';
import './lodash-es/_baseIsEqual.js-2081c9b2.js';
import './lodash-es/_baseIsMatch.js-fe8d464f.js';
import './lodash-es/_isStrictComparable.js-a9828370.js';
import './lodash-es/_getMatchData.js-8a722ba0.js';
import './lodash-es/_matchesStrictComparable.js-d19af892.js';
import './lodash-es/_baseMatches.js-39913338.js';
import './lodash-es/_baseGet.js-a279f2a7.js';
import './lodash-es/get.js-addb1d30.js';
import './lodash-es/_baseHasIn.js-5eb272a4.js';
import './lodash-es/_hasPath.js-cb394a0c.js';
import './lodash-es/hasIn.js-2f0ad596.js';
import './lodash-es/_baseMatchesProperty.js-5334e4c8.js';
import './lodash-es/_baseProperty.js-00c82e77.js';
import './lodash-es/_basePropertyDeep.js-e8318885.js';
import './lodash-es/property.js-ddd8f638.js';
import './lodash-es/_baseIteratee.js-718e1a1e.js';
import './lodash-es/_isFlattenable.js-8ef4abd2.js';
import './lodash-es/_baseFlatten.js-8b85ebbc.js';
import './lodash-es/flatten.js-06038df6.js';
import './lodash-es/_flatRest.js-d229910c.js';
import './lodash-es/_createOver.js-5e666ff5.js';
import './lodash-es/overEvery.js-85c2260f.js';
import './lodash-es/overSome.js-2ada7e25.js';
import './lodash-es/_baseForOwn.js-f2105544.js';
import './lodash-es/_createBaseEach.js-2bcc6476.js';
import './lodash-es/_baseEach.js-f31c688f.js';
import './lodash-es/_baseMap.js-781eedcf.js';
import './lodash-es/_baseSortBy.js-2eea9fb7.js';
import './lodash-es/_compareAscending.js-b327f9ec.js';
import './lodash-es/_compareMultiple.js-4ef115e3.js';
import './lodash-es/_baseOrderBy.js-1c53f017.js';
import './lodash-es/sortBy.js-cfaf310e.js';
import './lodash-es/isString.js-650ac401.js';
import './lodash-es/_basePickBy.js-9e8e587d.js';
import './lodash-es/_basePick.js-4883a589.js';
import './lodash-es/pick.js-88ae7d68.js';
import './lodash-es/uniqueId.js-cdc34c97.js';
import { memoize, ensureArray, ensurePropIsObject, keyBy, transToObject, reduce } from './fp-utils.js';

const getDefName=schemaDefinition=>schemaDefinition.name.value;
const getFieldTypeName=fieldDefinition=>{
  let type=fieldDefinition.type;
  while(type.kind!=='NamedType')type=type.type;
  return type.name.value;
};
const isListField=fieldDefinition=>{
  const type=fieldDefinition.type;
  return (type.kind==='NonNullType'?type.type.kind:type.kind)==='ListType';
};
var indexSchema = memoize(schema=>{
  const definitions=ensureArray(schema.definitions).filter(d=>/^(Query|Mutation|Subscription)$/.test(d.name.value)===false);
  // const builtInDefinitions=['ID','Int','Float','String','Boolean']
  //   .map(value=>({kind:'ScalarTypeDefinition',name:{value}}));
  const builtInDefinitions=[];
  const allDefs=builtInDefinitions.concat(definitions);
  const definitionsByKind=allDefs.reduce((acc,d)=>{ensurePropIsObject(acc,d.kind)[d.kind][d.name.value]=d;return acc},{});
  const objectDefs=Object.values(definitionsByKind.ObjectTypeDefinition);
  return {
    ...definitionsByKind,
    definitions:allDefs,
    definitionsByName:keyBy(allDefs,getDefName),
    objectFieldMeta:Object.values(definitionsByKind.ObjectTypeDefinition).reduce((acc,d)=>{
      const dName=getDefName(d);
      const m=acc[dName]={scalarNames:{},collectionNames:{},collectionKeysCount:0,scalarKeysCount:0,isListType:{},idKey:undefined};
      for (const f of d.fields){
        const [fName,fTypeName]=[getDefName(f),getFieldTypeName(f)];
        if (fTypeName==='ID') m.idKey=fName;
        m.isListType[fName]=isListField(f);
        if  (fTypeName in definitionsByKind.ObjectTypeDefinition) {
          m.collectionNames[fName]=fTypeName;
          ++m.collectionKeysCount;
        } else {
          ++m.scalarKeysCount;
          m.scalarNames[fName]=fTypeName;
        }
      }
      return acc;
    },{})
  }
});

const schemaToActionCreators=( schema )=>{};
const schemaToQueries=( schema )=>{};
const schemaToMutations=( schema )=>{};
const extendSchemaWithQueryAndMutationDefinitions=( schema )=>{};

const schemaToReducers=( schema = gql('type DefaultType {id:ID!}') )=>{
  const {objectFieldMeta,ObjectTypeDefinition,definitionsByName}=indexSchema(schema);
  return Object.keys(definitionsByName).reduce((acc,dName)=>{
    const idKey=objectFieldMeta[dName]?.idKey;
    
    const NAME=dName.toUpperCase();
    const [UNION,INTERSECTION,ADD,SUBTRACT,SET,GET]=['UNION','INTERSECTION','ADD','SUBTRACT','SET','GET']
      .map(OP=>`${OP}_${NAME}`);
    const collDiffer=diffBy(idKey);
    acc[dName]=(prevState=null,action={type:GET,payload:{}})=>{
      let {type,payload={}}=action;
      
      if (type===GET) return prevState;

      if (type===SET) return payload;
      
      if(idKey===undefined)return prevState;
      if (typeof payload !== 'object') payload={[payload]:{[idKey]:payload}}; // convert number to collection shape
      else if (idKey in payload) payload={[payload[idKey]]:payload}; // convert item to collection shape
      
      if (type===ADD) return {...prevState,...payload};
      
      const diff = collDiffer([prevState,payload]);
      let nextState={},k;
      
      if (type===SUBTRACT) {
        if (diff.aibc===0) return prevState; // no intersection to remove
        if (diff.aibc===diff.aubc) return nextState; // complete intersection. remove everything
        for (k in diff.anb)nextState[k]=prevState[k]; // copy non-intersecting collection items to new state
        return nextState;
      }
      
      if (type===UNION){
        for (k in diff.aub)nextState[k]=payload[k]??prevState[k];
        return diff.changedc===0?prevState:nextState;
      }
      
      if (type===INTERSECTION){
        for (k in diff.aib)nextState[k]=payload[k];
        return diff.changedc===0?prevState:nextState;
      }
      
      return prevState;
    };
    return acc;
  },{});
};







const getMemoizedObjectQuerier=(schema)=>{
  const {objectFieldMeta,definitionsByName}=indexSchema(schema);
  
  const matches = args=>v=>{
    for (const arg in args)
      if(v[arg]!==args[arg])
        return false;
    return true;
  };
  const populateArgsFromVars = (args=[],vars={})=>{
    let result={},name,kind,value;
    for ({name:{value:name},value:{kind,value}} of args){
      result[name] = kind==='Variable' ? vars[name] : value;
      // may need to delist and denull here
    }
    return result;
  };
  const variableDefinitionsToObject = (variableDefinitions=[],passedVariables={})=>{
    let vars = {},name,defaultValue;
    // default per spec is returning only what's in variableDefinitions, but this eliminates the duplicate definitions just to pass a variable for less boilerplate.  Can always change it to the more verbose version and add validation.
    if (variableDefinitions.length===0) return passedVariables;
    for ({variable:{name:{value:name}},defaultValue} of variableDefinitions)
      vars[name]=passedVariables[name]!==undefined ? passedVariables[name] : defaultValue?.value;
      // may need to de-null and de-list here.f
    return vars;
  };

  const queryObjectCollection = ( (rootState,collName,id,Field,vars)=>{
    if (Field.selectionSet===undefined){ // leaf
      if (id===undefined){
        return (Field.name.value in rootState)
          ? rootState[Field.name.value] // root scalars
          : new Error('cannot request collection without selecting fields');
      }
      if(Field.name.value in objectFieldMeta[collName].collectionNames)
        return new Error('cannot request object without selecting fields');
      return rootState[collName][id][Field.name.value]; // prop scalars
      // return new Error('just get the property selection')
    }
    if (id === undefined){
      // what if we're filtering the collection
      if (Field.arguments.length===0)
        return transToObject((o,_,k)=>o[k]=queryObjectCollection(rootState,collName,k,Field,vars))(rootState[collName]);
        
      const args = populateArgsFromVars(Field.arguments,vars);
      const matchesFn = matches(args);
      return transToObject(
        (o,item,k)=>matchesFn(item)&&(o[k]=queryObjectCollection(rootState,collName,k,Field,vars))
      )(rootState[collName]);
    }
    const {collectionNames,collectionKeysCount}=objectFieldMeta[collName];

    if (Array.isArray(id))
      return transToObject((o,k)=>o[k]=queryObjectCollection(rootState,collName,k,Field,vars))(id);
    
    let f,fName,newItem={},item=rootState[collName][id];
    for (f of Field.selectionSet.selections){
      fName=f.name.value;
      newItem[fName]=(fName in collectionNames)
        ? queryObjectCollection( rootState, collectionNames[fName], item[fName],f, vars)
        : item[fName];
    }
    return newItem;
  });

  const getVarsKey = vars=>{
    const keys=Object.keys(vars).sort();
    return keys.join(',') + keys.map(k=>JSON.stringify(vars[k])).join(',');
  };

  const queryStateWithOperation = (rootState,operation,passedVariables={})=>
    operation.definitions.reduce((result,op)=>{
      const vars = variableDefinitionsToObject(op.variableDefinitions,passedVariables);
      for (const s of op.selectionSet.selections||[])
        result[s.name.value]=queryObjectCollection(rootState,s.name.value,undefined,s,vars);
      return result;
    },{});

  const getFieldCollectionNames=reduce((acc,{name:{value},selectionSet:{selections=[]}={}},i,c)=>{
    if (value in definitionsByName) acc.add(value);
    return getFieldCollectionNames(selections,acc);
  });

  const getQueryCollectionNames = reduce((acc=new WeakSet(),{selectionSet:{selections=[]}={}})=>getFieldCollectionNames(selections,acc));
  
  
  let prevState={};
  let operations=new WeakSet();
  let queryResults=new WeakMap();
  let collectionKeysByQuery=new WeakMap();
  return (state,operation,vars={})=>{
    const varsKey=getVarsKey(vars);
    if (!operations.has(operation)){
      operations.add(operation);
      collectionKeysByQuery.set(operation,getQueryCollectionNames(operation.definitions,new Set()));
      const result = queryStateWithOperation(state,operation,vars);
      queryResults.set(operation,{[varsKey]:result});
      prevState=state;
      return result;
    }

    if (prevState!==state)
      for (const k of collectionKeysByQuery.get(operation))
        if(prevState[k]!==state[k]){
          prevState=state;
          return queryResults.get(operation)[varsKey] = queryStateWithOperation(state,operation,vars);
        }
    
    const opResults=queryResults.get(operation);
    return varsKey in opResults
      ? opResults[varsKey]
      : (opResults[varsKey] = querier(state,operation,vars));
  }
};


/* eslint-disable @typescript-eslint/no-use-before-define */
/*
 * General Utils
 */
// import-free equivalent-lodash-function-named one-liners for-bundle-size
// see https://lodash.com/docs/ for descriptions and repl
// export const isArray = Array.isArray;
// export const isFunction = x => typeof x === 'function';
// export const stubArray = () => [];
// export const stubObject = () => Object.create(null);
// export const isPromise = x=>typeof x==='object'&&typeof x.then==='function';
// export const curryN = (n = 1, fn) => (...args) => (n <= args.length) ? fn(...args) : curryN(n - args.length, (...more) => fn(...args, ...more));
// // @ts-ignore: tslint dislikes these
// export const over = (fns = []) => (...args) => fns.map(f => f(...args));
// // @ts-ignore: tslint dislikes these
// export const keyBy = (by = x => x.id) => (a = []) => { const o = {}, l = a.length; let i = -1; while (++i < l) (o[by(a[i])] = a[i]); return o; }
// // @ts-ignore: tslint dislikes these
// export const flow = (fn = identity, ...fns) => (...args) => { const l = fns.length; let i = -1, a = fn(...args); while (++i < l) (a = fns[i](a)); return a; }
// // @ts-ignore: tslint dislikes these

// export const pick = keys => o => { let i = -1; const l = keys.length, acc = Object.create(null); while (++i < l) (acc[keys[i]] = o[keys[i]]); return acc; }


// export const invert = obj => transx((acc, v1, k1) => mapx((v2, k2) => {
//   (acc[k2] || (acc[k2] = {}))[k1] = v2;
// })(v1))(obj);
// const getMemoizedLenses = (keys,rw,kind)=>transArrayToObj((o,k)=>lenses[k]&&lenses[k][kind]&&(o[k]=lenses[k][kind][rw]))(keys.split(','))



// common op. imperative implementation for speed.
const transDiff = (fn = identity, { by = x => x.id, subset = 'aub', ret } = {}) => (collections = []) => {
  const diff = diffBy(by, collections);
  if (ret === undefined) (ret = isArray(collections[0]) ? [] : Object.create(null));
  const { anb, bna, aib, aub, changed, a, b, [subset]: sub } = diff;
  const reused = Object.create(diff);
  let k;
  for (k in sub) {
    reused.anb = anb[k];
    reused.bna = bna[k];
    reused.aib = aib[k];
    reused.aub = aub[k];
    reused.changed = changed[k];
    reused.a = a[k];
    reused.b = b[k];
    reused.k = k;
    fn(ret, a[k], b[k], reused);
  }
  return ret;
};

// export const diffBy = (by, reducer) => (args = []) => {
//   const diff = by ? diffObjs(args.map(keyBy(by))) : diffObjs(args);
//   const { anb, anbc, bna, bnac, aib, aibc, aub, aubc, changed, changedc, a, b } = diff;
//   const reused = { anb, anbc, bna, bnac, aib, aibc, aub, aubc, changed, changedc, a, b };
//   // eliminate one of the three loops by combining this directly with diffObjs
//   // put the first loop before the iterator, and the second in iterator, yielding while it goes
//   // cons:
//   // unsure how much of a performance hit iterable protocol is. Would need to test that.
//   // counts inaccurate until after.  Keeping separate for now.
//   // reused.diff = diff;
//   if (reducer) {
//     let k, acc;
//     for (k in aub) {
//       reused.anb = anb[k];
//       reused.bna = bna[k];
//       reused.aib = aib[k];
//       reused.aub = aub[k];
//       reused.changed = changed[k];
//       reused.a = a[k];
//       reused.b = b[k];
//       reused.k = k;
//       acc = reducer(acc, reused, k);
//     }
//     return acc;
//   } else {
//     // uncertain if this has performance benefits.  Need to test.
//     reused[Symbol.iterator] = reused.next = function* () {
//       let k;
//       for (k in aub) {
//         reused.anb = anb[k];
//         reused.bna = bna[k];
//         reused.aib = aib[k];
//         reused.aub = aub[k];
//         reused.changed = changed[k];
//         reused.a = a[k];
//         reused.b = b[k];
//         reused.k = k;
//         yield reused;
//       }
//     };
//     return reused;
//   }
// };

// Common case: transforming two graphs is special case of transforming one, where the reducer derives
// a third graph while walking. The derived graph's nodes are pairs of [ANode,BNode]
// TODO more efficient (i.e. non-array resizing) queue implementation
// some initial research led to https://github.com/invertase/denque
// const noopGraphReducer = (acc, currentNode, addNextNode = (nodes = []) => []) => acc;
// export const reduceGraphBF = (reducer = noopGraphReducer, startNodes = []) => {
//   const queue = [...startNodes];
//   const addNextNode = node => { queue[queue.length] = node; }
//   let acc, node;
//   while (node = queue.shift()) (acc = reducer(acc, node, addNextNode));
//   return acc;
// };

// export const EitherValueOrError = fn => resolverArg => {
//   try { return fn(resolverArg) }
//   catch (e) {
//     return { ...resolverArg }
//   };
//   if (arg instanceof Error) return fn(arg)
// }
// export const EitherValuePromiseOrWonkaStream = (arg, fn) => {
//   if (typeof arg === 'function') return toPromise(arg).then(fn, fn);
//   if (typeof arg === 'object' && typeof arg.then === 'function') return arg.then(fn, fn);
//   return fn(arg);
//   try { return fn(arg) }
//   catch (e) { return catcher(e) };
// }
// const EitherValuePromiseOrStream = (fn) => {
//   if (typeof arg === 'object' && typeof arg.then === 'function') return arg.then(fn, catcher);
//   if (typeof arg === 'function') return toPromise(arg).then(fn, catcher);
//   if (typeof arg === 'object' && typeof arg.then === 'function') return arg.then(fn, catcher);
//   try { return fn(arg) }
//   catch (e) { return catcher(e) };
// }

// const astReducers={
//   Document:({definitions=[]})=>definitions,
//   OperationDefinition:({selectionSet:{selections=[]}={}}={})=>selections,
//   Field:({selectionSet:{selections=[]}={}}={})=>selections,
// };
// // get rid of the transducers for the recursive stuff
// const queryReducer=(rArg,fn)=>{
//   fn(rArg);
//   for (const c of astReducers[rArg.astNode.kind](rArg.astNode))
//     queryReducer(fn,makeResolverArg({parent:rArg,astNode:c}));
//   return rArg;
// };

// export const makeAstKindTransducers=(key,reader,writer)=>{
//   const titledKey=key[0].toUpperCase()+key.slice(1);
//   const result={};
//   reader && (result['read'+titledKey] = nextReducer=>(parent,ra)=>{
//     reader(parent,ra);
//     ra.outputArray[ra.outputArray.length]=ra.context[key];
//     nextReducer(parent,ra);
//     return parent;
//   });
//   writer && (result['write'+titledKey] = nextReducer=>(parent,ra)=>{
//     writer(parent,ra);
//     nextReducer(parent,ra);
//     return parent;
//   });
//   return result;
// }

// export const readData = nextReducer=>(parent,ra)=>{
//   if(ra===parent) {
//     parent.context.data=parent.data;
//   } else {
//     parent.context.data[ra.nameValue]||(parent.context.data[ra.nameValue]={});
//     ra.context.data=parent.context.data[ra.nameValue];
//   }
//   // if(ra.nameValue in (parent.context.data)){
//   //   ra.context.data=parent.context.data[ra.nameValue];
//   //   ra.outputArray[ra.outputArray.length]=ra.context.data;
//   // } else {
//   //   parent.context.data[ra.nameValue]=ra.context.data={};
//   // }
//   nextReducer(parent,ra);
//   return parent;
// }
// export const writeData = nextReducer=>(parent,ra)=>{
//   if (parent===ra){
//     ra.data=ra.context.data||{};
//   }
//   if (ra.outputArray.length){
//     ra.context.data=ra.outputArray[ra.outputArray.length-1]
//   }
//   if (ra.context.data){
//     if(ra!==parent){
//       parent.context.data||(parent.context.data={});
//       parent.context.data[ra.nameValue]=ra.context.data;
//     } else {
//       parent.data=parent.context.data;
//     }
//   }
//   nextReducer(parent,ra);
//   return parent;
// };

// export const stateTransducersFactory = (initialState={})=>{
//   let state = {...initialState};
//   return makeAstKindTransducers('state',
//     (parent,ra)=>{
//       if (ra===parent){
//         ra.context.state = parent.context.state = state;
//       } else {
//         ra.context.state=parent.context.state[ra.nameValue]??parent.context.state;
//       }
//         // ? state
//         // : parent.context.state[ra.nameValue];
//       return parent;
//     },
//     (parent,ra)=>{
//       parent===ra
//         ? (state!==ra.context.state && (state=ra.context.state))
//         : (ra.context.state=ra.outputArray[ra.outputArray.length-1]);
//       return parent;
//     },
//   );
// };

// export const schemaToResolverMap=(schema)=>{
//   const definitionsByName={
//     ...keyBy(s=>s)(
//       'ID,Int,Float,String,Boolean'
//         .split(',')
//         .map(s=>({[s]:{kind:"ScalarTypeDefinition",name:{value:s}}}))
//     ),
//     ...keyBy(d=>d.name.value)(schema.definitions)
//   };
//   const kindTransducers={
//     ScalarTypeDefinition:nextReducer=>ra=>nextReducer(ra),
//     // queryReducer(makeResolverArg({astNode:c,parent:resolverArg}))
//     ObjectTypeDefinition:nextReducer=>ra=>transduce(ra,kindTransducers.FieldDefinition,nextReducer,ra.astNode.fields),
//     FieldDefinition:nextReducer=>ra=>transduce(ra,kindTransducers[ra.type.kind],nextReducer,ra.astNode.fields),
//     NonNullType:nextReducer=>ra=>transduce(ra,kindTransducers[ra.type.kind],nextReducer,{...ra.astNode,type:ra.astNode.type.type}),
//     ListType:nextReducer=>ra=>transduce(ra,kindTransducers[ra.type.kind],nextReducer,ra.astNode.fields),
//     NamedType:nextReducer=>ra=>{
//       console.log(`definitionsByName[ra.astNode.name.value].kind`, definitionsByName[ra.astNode.name.value].kind);
//       if (namedTransducers[ra.astNode.name.value]===undefined)
//         namedTransducers[ra.astNode.name.value] = kindTransducers[definitionsByName[ra.astNode.name.value].kind];
//       return transduce(ra,namedTransducers[ra.astNode.name.value],nextReducer,ra);
//     },
//   };
//   const namedTransducers  = tdToObject(tdMap(({kind})=>kindTransducers[kind]))(definitionsByName);
//   return namedTransducers;
// }
//
// export const maybePromise = (arg, onSuccess) => {
//   if (typeof arg==='object'&&arg.then) return arg.then(onSuccess);
//   return onSuccess(arg);
// };
//
// export const flowPossiblePromises = (...fns) => arg => fns.reduce(maybePromise, arg);
//
// export const mapToPossiblePromise = (array, fn) => {
//   let x, result, hasPromises;
//   const vals = [];
//   vals.hasPromises=false;
//   for (x of array) {
//     result = fn(x)
//     if (result.then) vals.hasPromises = true;
//     vals[vals.length] = result;
//   }
//   return hasPromises ? Promise.all(vals) : vals;
// }

// type IdentityType = <T>(arg: T) => T;
// interface IdentityType { <T>(arg: T): T };
// interface IdentityType<T> { (arg: T): T };
// define type and identity
// const identity: (<T>(x: T) => T) = x => x;
// function identity<T>(x: T): T { return x; }
// const hasProp = (prop: string) => (x: object | function): bool => prop in x;
// const isString = (x): bool => typeof x === 'string';
// const isArray = (x): bool => Array.isArray(x);
// const isUndefined = (x): bool => x === undefined;
// const isNull = (x): bool => x === null;
// const isJSMap = (x): bool => x instanceof Map;
// const mapArray = (f: ItemMapper) => (c: array): array => c.map(f);
// const mapObject = (f: ItemMapper) => { };


// const getType = (x: null | undefined | array | function | number | string | object): string => {
//   if (x === null) return 'null';
//   if (x === undefined) return 'undefined';
//   if (Array.isArray(x)) return 'array';
//   if (x instanceof Function) return 'function';
//   if (x instanceof Number) return 'number';
//   if (x instanceof String) return 'string';
//   if (x instanceof Error) return 'error';
//   if (typeof x === 'object') return 'object';
//   return 'object';
// };
// const isEmpty: Predicate = (x: null | undefined | array | function | number | string | object): boolean => {
//   if (x === null) return true;
//   if (x === undefined) return true;
//   if (Array.isArray(x)) return x.length === 0;
//   if (x instanceof Function) return false;
//   if (x instanceof Number) return x === 0;
//   if (x instanceof String) return x === '';
//   if (typeof x === 'object') return Object.keys(x).length === 0;
//   return false;
// };

// const Just = x => ({
//   map: f => x => Just(f(x)),//
//   flatMap: f => x => f(x),
//   chain: f => x => f(x),
//   extract: () => x,
//   ap: anotherMonad => map(anotherMonad)(x),
//   isEmpty: () => false,
//   inspect: () => `Just(${x})`
// });
// const Nothing = x => ({
//   map: Nothing,
//   flatMap: f => x => f(undefined),
//   chain: f => x => f(undefined),
//   extract: () => undefined,
//   ap: Nothing,
//   isEmpty: () => true,
//   inspect: () => "Nothing",
//   // hylo:()=>{},
//   // hylo:()=>{},
// });
//
// const Identity = x => ({
//   // Transform the inner value
//   // map :: Identity a ~> (a -> b) -> Identity b
//   map: f => Identity(f(x)),
//   flatMap: f => x => f(x),
//   chain: f => x => f(x),
//   ap: anotherMonad => map(anotherMonad)(x),
// });
//
// const Lens = x => ({
//
// });
// const Transducer = x => ({
//
// });
//
// const ifElse = (pred, ifTrue, ifFalse) => x => (pred(x) ? ifTrue : ifFalse)(x);
// const Maybe = ifElse(isEmpty, Nothing, Just);
// const maybeProp = prop => compose(prop[x])prop=> (x = {}) => Maybe(x[prop]);
//
//
// type Just;
// type Nothing;
// type Maybe = Just | Nothing;
// export const EitherValOrError = {
//   map: f => x => x instanceof Error ? x : f
//   empty: x =>
//     of: x=> EitherValOrError
// }
// export const transducer
//
// export const lens = getter => setter => { };

  // resolverArg.writes.data = resolverArg.data??{};
//   const parent = resolverArg.parent;
//   let name;
//   if (resolverArg.kind==='OperationDefinition'){
//     nextReducer(resolverArg);
//
//     ||resolverArg.astNode.operation;
//   } else if (resolverArg.kind==='Field'){
//     name = resolverArg.astNode.name.value;
//     resolverArg.reads[resolverArg.readsIndex++] = resolverArg.writes.data = resolverArg.data;
//   }
//   return nextReducer(resolverArg);
//
//     // parent.data=parent.writes.data={...parent.writes.data,[name]:resolverArg.resolverOutput};
//   }
//   return nextReducer(resolverArg);
//   // switch (resolverArg.astNode.kind){
//   //   case 'OperationDefinition':
//   //     return nextReducer(resolverArg);
//   //   case 'Field':
//   //     if (parent.writes.data[name]!==resolverArg.resolverOutput){
//   //       resolverArg.writes.data=resolverArg.resolverOutput;
//   //       parent.data=parent.writes.data={...parent.writes.data,[name]:resolverArg.resolverOutput};
//   //     }
//   //     return nextReducer(resolverArg);
//   //   default :
//   //     return nextReducer(resolverArg);
//   // }
// };
// reads data and state from ra.writes{data,state,variables,arguments}

// 6.1.2 http://spec.graphql.org/draft/#sec-Coercing-Variable-Values
// const readVariables=makeAstKindTransducers({ // eslint-disable-line no-unused-vars
//
//   Field:ra=>{
//     const resolver = ra.parent.writes.resolver[ra.astNode.name.value]
//     if (resolver!==undefined){
//       ra.writes.resolver = resolver[ra.IO]||resolver;
//     }
//   }
// });

// 6.4.1 http://spec.graphql.org/draft/#sec-Coercing-Field-Arguments
// const readArguments=nextReducer=>(resolverArg)=>{nextReducer(resolverArg)}; // eslint-disable-line no-unused-vars


// export const resolverTransducerFactory = resolverMap=>{
//   const readResolver = makeAstKindTransducers({
//     OperationDefinition:ra=>{
//       if (resolverMap[ra.astNode.operation]===undefined){
//         console.log(`"${ra.astNode.operation}" missing from resolver map`);
//         return ra;
//       }
//       ra.writes.resolver=resolverMap[ra.astNode.operation];
//       return ra;
//     },
//     Field:ra=>{
//       console.log(`readResolver ra`, ra);
//       const resolver = ra.parent.writes.resolver[ra.astNode.name.value]
//       if (resolver!==undefined){
//         ra.writes.resolver = resolver[ra.IO]||resolver;
//       }
//     }
//   });
//   return {readResolver};
// };

// const makeLens = lens => {
//   // freeze the lens to to prevent composing lenses from accidentally redefining its fns
//   // ensure functions defined for all crawlable kinds
//   const frozen = Object.freeze(lens);
//   return exchangeKey => frozen;
// }
//
// // TODO evaluate if removing makeLensFactory's conditionals is possible
// // without making a bunch of extra api functions to learn
// const makeLensFactory = getLens => {
//   let cache;
//   return userDefinedData => {
//     if (cache === undefined) {
//       if (userDefinedData === undefined) throw new Error('First lens factory call must supply initial data.');
//
//       // Cache cache. Prevents redefinition so composing lenses calling this factory
//       // can access shared exchange and client-level data. Also fun to say.
//       cache = stubObject();
//     }
//
//     return (key = '__client__') => {
//       if (cache[key]) return cache[key];
//       // freeze the lens to to prevent composing lenses from accidentally redefining its fns
//
//       // ensure functions defined for all crawlable kinds to prevent errors further down the chain
//       const lens = Object.freeze(getLens(userDefinedData));
//       // prevent non-instantiated factories from creating super-difficult-to-trace bugs.
//       if (typeof key === 'object') {
//         throw new Error(`lensFactory missing userDefinedData for ${lens}.`)
//       }
//       // cache the lense with its closured userDefinedData for composing lens' "read" calls
//       return (cache[key] = lens);
//     };
//   }
// }
//
// //
// // FragmentSpread
// // https://graphql.github.io/graphql-spec/June2018/#index
// const identity = resolverArg => resolverArg;
// export const fragments = () => ({
//   // Document: { read: identity, write: identity },
//   // needs typedefs
//   FragmentSpread: { read: identity, write: identity },
//   FragmentDefinition: { read: identity, write: identity },
//   InlineFragment: { read: identity, write: identity },
// });
// export const fields = () => ({
//   // Document: { read: identity, write: identity },
//   // needs typedefs
//   OperationDefinition: { read: identity, write: identity },
//   Field: { read: identity, write: identity },
// });
// export const arguments = () => ({
//   Field: { read: f => transArrayToObj((o, v, k) => { o[v.name.value] = v.value.value })(f.arguments) }
// });
// export const alias = () => ({
//   // Document: { read: identity, write: identity },
//   Field: { read: identity, write: identity },
// });
// export const directives = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });
// export const state = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });
// export const data = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });
// export const context = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });
// export const info = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });
// export const errors = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });
// export const preventForward = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });
// export const returnOp = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });
// export const typeValidation = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });
// export const nullability = () => ({
//   operation: { read: identity, write: identity },
//   definition: { read: identity, write: identity },
//   selection: { read: identity, write: identity },
// });

export { extendSchemaWithQueryAndMutationDefinitions, getMemoizedObjectQuerier, schemaToActionCreators, schemaToMutations, schemaToQueries, schemaToReducers, transDiff };
